export class InputManager {

    constructor(handler) {
        this.handler = handler;
        this.down = new Set();
       //okay so we have a set of keys currently pressed
       //these are relative to the canvas, only way to do it reliably i feel
       this.mouseX = 0;
       this.mouseY = 0;
    }

    attachListeners(canvas, on){
        on(window, 'keydown', (e) => {this.down.add(e.code);});
        on(window, 'keyup', (e) => {this.down.delete(e.code);});
        on(canvas, 'mousedown',(e) => {
            if(e.button == 0) this.down.add("leftMouseBTN");
            if(e.button == 1) this.down.add("rightMouseBTN");
            if(e.button == 2) this.down.add("middleMouseBTN");
            let {x, y} = this._getMouseOnCanvas(e, canvas);
            this.mouseX = x;
            this.mouseY = y;
            //console.log(`Mouse down Button ${e.button} ${e.offsetX},${e.offsetY} `)
        });
        on(canvas, 'mouseup',(e) => {
            if(e.button == 0) this.down.delete("leftMouseBTN");
            if(e.button == 1) this.down.delete("rightMouseBTN");
            if(e.button == 2) this.down.delete("middleMouseBTN");
            let {x, y} = this._getMouseOnCanvas(e, canvas);
            this.mouseX = x;
            this.mouseY = y;
            //console.log(`Mouse up Button ${e.button} ${e.offsetX},${e.offsetY} `)
        });
        on(canvas, 'mousemove',(e) => {
            //console.log(`Mouse move Button ${e.button} ${e.offsetX},${e.offsetY} `)
            let {x, y} = this._getMouseOnCanvas(e, canvas);
            this.mouseX = x;
            this.mouseY = y;
        });
    }


    // Use this in your InputManager
    _getMouseOnCanvas(e, canvas) {
    const rect = canvas.getBoundingClientRect();
    /*
        This function was generated by ChatGPT, our problem was that the mouse event captures the mouse coords in css pixels,
        and it also doesnt account for border sizing on the css element, (?) We fix by accounting for border size and any scaling difference,
        and scaling from game canvas size to that size. returns the mouse coords x and y, used in our mouse event functions.   
    
    */
    // Account for CSS border/padding (border-box rect includes borders)
    const cs = getComputedStyle(canvas);
    const borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);
    const borderY = parseFloat(cs.borderTopWidth)  + parseFloat(cs.borderBottomWidth);
    const cssDrawableW = rect.width  - borderX;
    const cssDrawableH = rect.height - borderY;

    // Scale from CSS pixels to canvas pixels (backing store)
    const scaleX = canvas.width  / cssDrawableW;
    const scaleY = canvas.height / cssDrawableH;

    // Client coords → CSS local → canvas pixels
    const x = (e.clientX - rect.left - parseFloat(cs.borderLeftWidth)) * scaleX;
    const y = (e.clientY - rect.top  - parseFloat(cs.borderTopWidth))  * scaleY;

    return { x, y };
    }


}

